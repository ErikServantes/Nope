<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="UTF-8">
    <title>Nope v1.5 – Configuração Interativa</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; color: white; font-family: Arial, sans-serif; }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }
      #diagnostics {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px;
        border-radius: 5px;
        font-size: 14px;
      }
      #configPanel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        max-height: 400px;
        overflow-y: auto;
        font-size: 12px;
      }
      input, label, button { font-size: 14px; margin:2px 0; }
      #ui button { width: 60px; height: 60px; font-size: 24px; }
      fieldset { border: 1px solid #555; margin-bottom: 8px; padding: 5px; }
      legend { font-size: 14px; }
    </style>
  </head>
  <body>
    <!-- Interface de Controlo Principal -->
    <div id="ui">
      <div>
        <label for="speedRange">Velocidade (1 a 10): <span id="speedValue">1</span>x</label><br>
        <input type="range" id="speedRange" min="1" max="10" step="1" value="1">
      </div>
      <div style="margin-top:8px;">
        <button id="speedDown">–</button>
        <button id="speedUp">+</button>
      </div>
      <div style="margin-top:8px;">
        <label for="dateInput">Data:</label><br>
        <input type="date" id="dateInput">
      </div>
      <div style="margin-top:8px;">
        <span id="currentDate"></span>
      </div>
      <div style="margin-top:8px; font-size:12px;">
        (Use mouse ou toque para orbitar, dar zoom e pan)
      </div>
    </div>

    <!-- Diagnóstico -->
    <div id="diagnostics">
      Zoom: <span id="zoomValue">0</span> units
    </div>

    <!-- Painel de Configuração de Parâmetros -->
    <div id="configPanel">
      <h3>Configuração de Planetas</h3>
      <div id="planetsConfig"></div>
      <button id="addPlanet">Adicionar Planeta</button>
      <hr>
      <h3>Configuração de Luas</h3>
      <div id="moonsConfig"></div>
      <button id="addMoon">Adicionar Lua</button>
    </div>

    <!-- Three.js e OrbitControls via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
      (function(){
        // =============================
        // Cena, câmera, renderer e controles
        // =============================
        let scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 20000);
        camera.position.set(0, 200, 500);
        
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        let textureLoader = new THREE.TextureLoader();
        
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 2000;
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth/window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // =============================
        // UI Elements Principais
        // =============================
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const speedDown = document.getElementById('speedDown');
        const speedUp = document.getElementById('speedUp');
        const dateInput = document.getElementById('dateInput');
        const currentDateLabel = document.getElementById('currentDate');
        const zoomValue = document.getElementById('zoomValue');
        
        let speedSetting = parseInt(speedRange.value);
        speedValue.textContent = speedSetting;
        speedDown.addEventListener('click', () => {
          speedSetting = Math.max(1, speedSetting - 1);
          speedRange.value = speedSetting;
          speedValue.textContent = speedSetting;
        });
        speedUp.addEventListener('click', () => {
          speedSetting = Math.min(10, speedSetting + 1);
          speedRange.value = speedSetting;
          speedValue.textContent = speedSetting;
        });
        speedRange.addEventListener('input', function(){
          speedSetting = parseInt(this.value);
          speedValue.textContent = speedSetting;
        });
        
        const refDate = new Date();
        dateInput.value = formatDate(refDate);
        let simulationTime = 0; // em dias
        dateInput.addEventListener('change', function(){
          let newDate = new Date(this.value);
          simulationTime = (newDate - refDate)/86400000;
        });
        function formatDate(date) {
          let yyyy = date.getFullYear();
          let mm = String(date.getMonth()+1).padStart(2,'0');
          let dd = String(date.getDate()).padStart(2,'0');
          return `${yyyy}-${mm}-${dd}`;
        }
        
        function deg2rad(deg) { return deg * Math.PI/180; }
        function solveKepler(M, e, tolerance=1e-6) {
          let E = M, delta = 1;
          while(Math.abs(delta) > tolerance) {
            delta = (E - e*Math.sin(E) - M)/(1 - e*Math.cos(E));
            E = E - delta;
          }
          return E;
        }
        
        // =============================
        // Criação do Sol e sua luz
        // =============================
        let sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        let sunTexture = textureLoader.load("sun-texture.jpg");
        let sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
        let sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.castShadow = false;
        sun.receiveShadow = false;
        scene.add(sun);
        
        let sunLight = new THREE.PointLight(0xffffff, 2, 10000);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.1;
        sunLight.shadow.camera.far = 20000;
        sunLight.shadow.bias = -0.005;
        sunLight.position.set(0,0,0);
        sun.add(sunLight);
        
        let sunSurfaceGeometry = new THREE.SphereGeometry(10 * 1.005, 32, 32);
        let sunSurfaceTexture = textureLoader.load("sun-surface.png");
        let sunSurfaceMaterial = new THREE.MeshPhongMaterial({
          map: sunSurfaceTexture,
          transparent: true,
          opacity: 0.7,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5
        });
        let sunSurfaceLayer = new THREE.Mesh(sunSurfaceGeometry, sunSurfaceMaterial);
        sunSurfaceLayer.castShadow = false;
        sunSurfaceLayer.receiveShadow = false;
        sun.add(sunSurfaceLayer);
        
        // =============================
        // Dados e Função de Criação dos Planetas
        // =============================
        // Parâmetros básicos dos planetas – estes serão editáveis na interface de configuração.
        const planetsData = [
          { name:"Mercúrio", a:0.387, e:0.2056, i:7.005, Ω:48.331, ω:29.124, M0:174.796, period:87.97, rotationPeriod:1407.6, axialTilt:0 },
          { name:"Vênus",   a:0.723, e:0.0068, i:3.394, Ω:76.680, ω:54.884, M0:50.115, period:224.70, rotationPeriod:-5832, axialTilt:177 },
          { name:"Terra",   a:1.000, e:0.0167, i:0.000, Ω:0.000,  ω:102.937, M0:357.517, period:365.256, rotationPeriod:24, axialTilt:23.5 },
          { name:"Marte",   a:1.524, e:0.0934, i:1.850, Ω:49.558, ω:286.502, M0:19.373,  period:686.980, rotationPeriod:24.6, axialTilt:25 },
          { name:"Nope",    a:1.59,  e:0.3,   i:90.0,  Ω:0.0,   ω:0.0,    M0:0.0,     period:730, rotationPeriod:26, axialTilt:45 },
          { name:"Júpiter", a:5.203, e:0.0489, i:1.304, Ω:100.464, ω:273.867, M0:20.020, period:4332.59, rotationPeriod:9.9, axialTilt:3 }
          // Outros planetas podem ser adicionados aqui.
        ];
        
        // Mapeamento de texturas – se um novo planeta for adicionado, poderá ser utilizada uma textura default.
        const textureMap = {
          "Mercúrio": { texture:"mercury-texture.jpg", displacement:"mercury-displacement.jpg", fallbackColor:0xffffff },
          "Vênus":   { texture:"venus-texture.jpg", displacement:"venus-displacement.jpg", fallbackColor:0xffffff },
          "Terra":   { texture:"earth-texture.jpg", displacement:"earth-displacement.jpg", fallbackColor:0xffffff },
          "Marte":   { texture:"mars-texture.jpg", displacement:"mars-displacement.jpg", fallbackColor:0xffffff },
          "Nope":    { texture:"nope-texture.jpg", displacement:"nope-displacement.jpg", fallbackColor:0xffffff },
          "Júpiter": { texture:"jupiter-texture.jpg", displacement:"jupiter-displacement.jpg", fallbackColor:0xffffff }
        };
        
        let planets = []; // Array que guardará os planetas já criados.
        
        // Função para criar o planeta e sua órbita com base no objeto planetData.
        function createPlanet(planetData) {
          let size;
          // Define o tamanho (pode ser alterado via interface)
          switch(planetData.name) {
            case "Mercúrio": size = 2.5; break;
            case "Vênus":   size = 3; break;
            case "Terra":   size = 3.5; break;
            case "Marte":   size = 3; break;
            case "Nope":    size = 3; break;
            case "Júpiter": size = 7; break;
            default:        size = planetData.size || 3;
          }
          planetData.size = size;
          let segments = (planetData.name==="Terra" || planetData.name==="Marte" || planetData.name==="Nope") ? 320 : 16;
          let geometry = new THREE.SphereGeometry(size, segments, segments);
          let texData = textureMap[planetData.name] || { texture:"default-texture.jpg", displacement:"default-displacement.jpg", fallbackColor:0xffffff };
          let texture = textureLoader.load(texData.texture);
          let displacement = textureLoader.load(texData.displacement);
          let material;
          if(planetData.name==="Terra" || planetData.name==="Marte" || planetData.name==="Nope") {
              material = new THREE.MeshStandardMaterial({ color: 0xffffff, map: texture, displacementMap: displacement, displacementScale: size * 0.025 });
          } else {
              material = new THREE.MeshStandardMaterial({ color: 0xffffff, map: texture });
          }
          
          let mesh;
          if(planetData.name==="Terra" || planetData.name==="Nope") {
            let pivot = new THREE.Group();
            let tiltGroup = new THREE.Group();
            pivot.add(tiltGroup);
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            tiltGroup.add(mesh);
            tiltGroup.rotation.z = deg2rad(planetData.axialTilt || 45);
            scene.add(pivot);
            planetData.pivot = pivot;
            planetData.tiltGroup = tiltGroup;
            planetData.mesh = mesh;
          } else {
            mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            planetData.mesh = mesh;
          }
          
          // Cria a linha da órbita
          let orbitPoints = (function(planet, numPoints=200){
            let pts = [];
            let a = planet.a, e = planet.e, i = deg2rad(planet.i),
                Ω = deg2rad(planet.Ω), ω = deg2rad(planet.ω);
            for(let j=0; j<=numPoints; j++){
              let f = 2*Math.PI*j/numPoints;
              let r = a*(1-e*e)/(1+e*Math.cos(f));
              let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Z = r*(Math.sin(ω+f)*Math.sin(i));
              let scale = 50;
              pts.push(new THREE.Vector3(X*scale, Z*scale, Y*scale));
            }
            return pts;
          })(planetData);
          let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
          let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
          let orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
          scene.add(orbitLine);
          planetData.orbitLine = orbitLine;
          
          planets.push(planetData);
        }
        
        // Cria os planetas iniciais
        planetsData.forEach(pd => createPlanet(pd));
        
        // =============================
        // Funções para Luas
        // =============================
        // Para cada planeta que tiver uma lua definida, criamos um grupo de órbita e o mesh da lua.
        // Inicialmente definimos uma lua para Terra e para Nope, mas pode ser adicionada via UI.
        function createMoon(planet, moonData) {
          let orbitGroup = new THREE.Group();
          scene.add(orbitGroup);
          let moonSize = moonData.size || (planet.size/4);
          let geometry = new THREE.SphereGeometry(moonSize, 160, 160);
          let texData = textureMap[moonData.name] || { texture: "default-moon-texture.jpg", displacement:"default-moon-displacement.jpg" };
          let texture = textureLoader.load(texData.texture);
          let displacement = textureLoader.load(texData.displacement);
          let material = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              map: texture,
              displacementMap: displacement,
              displacementScale: moonSize * 0.025,
              emissive: 0x444444,
              emissiveIntensity: 1
          });
          let mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          // Posição inicial da lua com base na distância definida
          mesh.position.set(moonData.distance || (planet.size + moonSize + 2), 0, 0);
          orbitGroup.add(mesh);
          moonData.orbitGroup = orbitGroup;
          moonData.mesh = mesh;
          if(!planet.moons) planet.moons = [];
          planet.moons.push(moonData);
        }
        
        // Lua da Terra (exemplo)
        let terra = planetsData.find(p => p.name==="Terra");
        if(terra) {
          createMoon(terra, { name:"Lua da Terra", period:10, distance:8, size: terra.size/4 });
        }
        // Lua de Nope (exemplo)
        let nope = planetsData.find(p => p.name==="Nope");
        if(nope) {
          createMoon(nope, { name:"Lua de Nope", period:0.25, distance:4.5, size: nope.size/16 });
        }
        
        // =============================
        // Interface de Configuração (Planetas e Luas)
        // =============================
        const planetsConfigDiv = document.getElementById("planetsConfig");
        const moonsConfigDiv = document.getElementById("moonsConfig");
        
        function updatePlanetsConfigUI() {
          planetsConfigDiv.innerHTML = "";
          planets.forEach((planet, index) => {
            let fieldset = document.createElement("fieldset");
            let legend = document.createElement("legend");
            legend.textContent = planet.name;
            fieldset.appendChild(legend);
            // Lista de parâmetros básicos editáveis: a, e, i, Ω, ω, M0, period, rotationPeriod, axialTilt, size
            const params = ["a","e","i","Ω","ω","M0","period","rotationPeriod","axialTilt","size"];
            params.forEach(param => {
              let label = document.createElement("label");
              label.textContent = param + ": ";
              let input = document.createElement("input");
              input.type = "number";
              input.step = "any";
              input.value = planet[param] || 0;
              input.addEventListener("change", function(){
                planet[param] = parseFloat(this.value);
                // Se alterar os parâmetros orbitais, recriaremos a órbita
                if(["a","e","i","Ω","ω"].includes(param)) {
                  scene.remove(planet.orbitLine);
                  let orbitPoints = (function(planet, numPoints=200){
                    let pts = [];
                    let a = planet.a, e = planet.e, i = deg2rad(planet.i),
                        Ω = deg2rad(planet.Ω), ω = deg2rad(planet.ω);
                    for(let j=0; j<=numPoints; j++){
                      let f = 2*Math.PI*j/numPoints;
                      let r = a*(1-e*e)/(1+e*Math.cos(f));
                      let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
                      let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
                      let Z = r*(Math.sin(ω+f)*Math.sin(i));
                      let scale = 50;
                      pts.push(new THREE.Vector3(X*scale, Z*scale, Y*scale));
                    }
                    return pts;
                  })(planet);
                  let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                  let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
                  let orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
                  scene.add(orbitLine);
                  planet.orbitLine = orbitLine;
                }
              });
              fieldset.appendChild(label);
              fieldset.appendChild(input);
              fieldset.appendChild(document.createElement("br"));
            });
            planetsConfigDiv.appendChild(fieldset);
          });
        }
        
        function updateMoonsConfigUI() {
          moonsConfigDiv.innerHTML = "";
          // Percorre todos os planetas que possuem luas
          planets.forEach((planet, pIndex) => {
            if(planet.moons && planet.moons.length) {
              planet.moons.forEach((moon, mIndex) => {
                let fieldset = document.createElement("fieldset");
                let legend = document.createElement("legend");
                legend.textContent = planet.name + " – " + moon.name;
                fieldset.appendChild(legend);
                // Parâmetros editáveis: period, distance, size
                const params = ["period","distance","size"];
                params.forEach(param => {
                  let label = document.createElement("label");
                  label.textContent = param + ": ";
                  let input = document.createElement("input");
                  input.type = "number";
                  input.step = "any";
                  input.value = moon[param] || 0;
                  input.addEventListener("change", function(){
                    moon[param] = parseFloat(this.value);
                  });
                  fieldset.appendChild(label);
                  fieldset.appendChild(input);
                  fieldset.appendChild(document.createElement("br"));
                });
                moonsConfigDiv.appendChild(fieldset);
              });
            }
          });
        }
        
        // Chamamos estas funções para construir a UI de configuração
        updatePlanetsConfigUI();
        updateMoonsConfigUI();
        
        // Botões para adicionar novos planetas e luas
        document.getElementById("addPlanet").addEventListener("click", function(){
          let newPlanet = {
            name: "NovoPlaneta",
            a: 2,
            e: 0.1,
            i: 5,
            Ω: 0,
            ω: 0,
            M0: 0,
            period: 500,
            rotationPeriod: 24,
            axialTilt: 23,
            size: 3
          };
          createPlanet(newPlanet);
          updatePlanetsConfigUI();
        });
        document.getElementById("addMoon").addEventListener("click", function(){
          // Adiciona uma nova lua ao primeiro planeta (por exemplo)
          if(planets.length) {
            let planet = planets[0];
            let newMoon = {
              name: "NovaLua",
              period: 5,
              distance: planet.size + 3,
              size: planet.size/4
            };
            createMoon(planet, newMoon);
            updateMoonsConfigUI();
          }
        });
        
        // =============================
        // Novo cálculo do target da câmera
        // =============================
        function updateControlsTarget() {
          let D = new THREE.Vector3().subVectors(nopeMeshPosition(), sun.position).normalize();
          let camOffset = new THREE.Vector3().subVectors(camera.position, sun.position);
          let projLength = camOffset.dot(D);
          let projectionPoint = sun.position.clone().add(D.clone().multiplyScalar(projLength));
          let vector2 = new THREE.Vector3().subVectors(camera.position, projectionPoint);
          let L = vector2.length();
          let t;
          if(L > 200) { t = 0; }
          else if(L < 50) { t = 1; }
          else { t = (200 - L) / 150; }
          let target = new THREE.Vector3().lerpVectors(sun.position, nopeMeshPosition(), t);
          controls.target.copy(target);
          zoomValue.textContent = "vector2 length: " + L.toFixed(2) + " | t: " + t.toFixed(2);
        }
        // Função para obter a posição de "Nope" (caso exista)
        function nopeMeshPosition() {
          let nopePlanet = planets.find(p => p.name==="Nope");
          if(nopePlanet && (nopePlanet.pivot || nopePlanet.mesh))
            return nopePlanet.pivot ? nopePlanet.pivot.position : nopePlanet.mesh.position;
          return new THREE.Vector3();
        }
        
        // =============================
        // Loop de Animação
        // =============================
        let lastFrameTime = performance.now();
        function animate() {
          requestAnimationFrame(animate);
          let now = performance.now();
          let dt = (now - lastFrameTime)/1000;
          lastFrameTime = now;
          
          let minSpeedFactor = 365.256/3600;
          let maxSpeedFactor = 100 * 365.256/3600;
          let speedFactor = minSpeedFactor + ((speedSetting - 1)/9) * (maxSpeedFactor - minSpeedFactor);
          simulationTime += dt * speedFactor;
          let simDate = new Date(refDate.getTime() + simulationTime*86400000);
          currentDateLabel.textContent = "Data Simulada: " + formatDate(simDate);
          
          // Atualiza posição e rotação dos planetas com base nos parâmetros editados
          planets.forEach(planet => {
            let pos = (function(planet, time) {
              let a = planet.a, e = planet.e, i = deg2rad(planet.i),
                  Ω = deg2rad(planet.Ω), ω = deg2rad(planet.ω), M0 = deg2rad(planet.M0),
                  period = planet.period;
              let n = 2*Math.PI/period;
              let M = (M0 + n*time) % (2*Math.PI);
              let E = solveKepler(M, e);
              let f = 2*Math.atan2(Math.sqrt(1+e)*Math.sin(E/2), Math.sqrt(1-e)*Math.cos(E/2));
              let r = a*(1 - e*Math.cos(E));
              let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Z = r*(Math.sin(ω+f)*Math.sin(i));
              let scale = 50;
              return new THREE.Vector3(X*scale, Z*scale, Y*scale);
            })(planet, simulationTime);
            if(planet.pivot) {
              planet.pivot.position.copy(pos);
            } else {
              planet.mesh.position.copy(pos);
            }
          });
          planets.forEach(planet => {
            if(planet.rotationPeriod) {
              let rotationPeriodDays = planet.rotationPeriod/24;
              let angle = simulationTime * (2*Math.PI/rotationPeriodDays);
              if(planet.pivot && planet.tiltGroup) {
                planet.tiltGroup.rotation.y = angle;
              } else {
                planet.mesh.rotation.y = angle;
              }
            }
          });
          
          // Atualiza posições das luas (para cada planeta que possua luas)
          planets.forEach(planet => {
            if(planet.moons) {
              planet.moons.forEach(moon => {
                // Movimento orbital simples da lua com base no período definido
                let moonAngle = (simulationTime * 2*Math.PI / moon.period) % (2*Math.PI);
                if(moon.orbitGroup)
                  moon.orbitGroup.rotation.y = moonAngle;
              });
            }
          });
          
          updateControlsTarget();
          controls.update();
          renderer.render(scene, camera);
        }
        animate();
      })();
    </script>
  </body>
</html>
