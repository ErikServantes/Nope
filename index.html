<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Simulação 3D do Sistema Solar com Rotação e Órbitas Corretas das Luas</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; color: white; font-family: Arial, sans-serif; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }
    input, label { font-size: 14px; }
  </style>
</head>
<body>
  <!-- Interface de Controle -->
  <div id="ui">
    <div>
      <label for="speedRange">Velocidade do tempo: <span id="speedValue">1</span>x</label><br>
      <input type="range" id="speedRange" min="1" max="1000" value="1">
    </div>
    <div style="margin-top:8px;">
      <label for="dateInput">Data:</label><br>
      <input type="date" id="dateInput">
    </div>
    <div style="margin-top:8px;">
      <span id="currentDate"></span>
    </div>
    <div style="margin-top:8px; font-size:12px;">
      (Use o mouse para orbitar, dar zoom e pan)
    </div>
  </div>

  <!-- Three.js e OrbitControls via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <script>
  (function(){
    // Configuração da cena, câmera, renderer e carregador de texturas
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
    camera.position.set(0, 200, 500);
    
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    let textureLoader = new THREE.TextureLoader();
    
    // Configuração dos controles (OrbitControls)
    let controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 3;
    controls.maxDistance = 2000;
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Interface de controle de tempo/data
    const speedRange = document.getElementById('speedRange');
    const speedValue = document.getElementById('speedValue');
    const dateInput = document.getElementById('dateInput');
    const currentDateLabel = document.getElementById('currentDate');
    
    let timeSpeed = Number(speedRange.value); // (dias por segundo)
    speedRange.addEventListener('input', function(){
      timeSpeed = Number(this.value);
      speedValue.textContent = timeSpeed;
    });
    
    const refDate = new Date();
    dateInput.value = formatDate(refDate);
    let simulationTime = 0; // em dias desde a data de referência
    
    dateInput.addEventListener('change', function(){
      let newDate = new Date(this.value);
      simulationTime = (newDate - refDate) / 86400000;
    });
    
    function formatDate(date) {
      let yyyy = date.getFullYear();
      let mm = String(date.getMonth() + 1).padStart(2, '0');
      let dd = String(date.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }
    
    // Função para converter graus em radianos
    function deg2rad(deg) {
      return deg * Math.PI / 180;
    }
    
    // Função para resolver a equação de Kepler: M = E - e*sin(E)
    function solveKepler(M, e, tolerance = 1e-6) {
      let E = M;
      let delta = 1;
      while (Math.abs(delta) > tolerance) {
        delta = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
        E = E - delta;
      }
      return E;
    }
    
    // Calcula a posição orbital do planeta (em unidades de cena) a partir dos elementos orbitais
    function getPlanetPosition(planet, time) {
      let a = planet.a;
      let e = planet.e;
      let i = deg2rad(planet.i);
      let Ω = deg2rad(planet.Ω);
      let ω = deg2rad(planet.ω);
      let M0 = deg2rad(planet.M0);
      let period = planet.period;
      
      let n = 2 * Math.PI / period;
      let M = M0 + n * time;
      M = M % (2 * Math.PI);
      
      let E = solveKepler(M, e);
      let f = 2 * Math.atan2(Math.sqrt(1 + e) * Math.sin(E / 2), Math.sqrt(1 - e) * Math.cos(E / 2));
      let r = a * (1 - e * Math.cos(E));
      
      let X = r * (Math.cos(Ω) * Math.cos(ω + f) - Math.sin(Ω) * Math.sin(ω + f) * Math.cos(i));
      let Y = r * (Math.sin(Ω) * Math.cos(ω + f) + Math.cos(Ω) * Math.sin(ω + f) * Math.cos(i));
      let Z = r * (Math.sin(ω + f) * Math.sin(i));
      
      let scale = 50;
      return new THREE.Vector3(X * scale, Z * scale, Y * scale);
    }
    
    // Gera pontos para desenhar a órbita (curva elíptica)
    function getOrbitPoints(planet, numPoints = 100) {
      let points = [];
      let a = planet.a;
      let e = planet.e;
      let i = deg2rad(planet.i);
      let Ω = deg2rad(planet.Ω);
      let ω = deg2rad(planet.ω);
      
      for (let j = 0; j <= numPoints; j++) {
        let f = 2 * Math.PI * j / numPoints;
        let r = a * (1 - e * e) / (1 + e * Math.cos(f));
        let X = r * (Math.cos(Ω) * Math.cos(ω + f) - Math.sin(Ω) * Math.sin(ω + f) * Math.cos(i));
        let Y = r * (Math.sin(Ω) * Math.cos(ω + f) + Math.cos(Ω) * Math.sin(ω + f) * Math.cos(i));
        let Z = r * (Math.sin(ω + f) * Math.sin(i));
        let scale = 50;
        points.push(new THREE.Vector3(X * scale, Z * scale, Y * scale));
      }
      return points;
    }
    
    // Dados dos planetas com elementos orbitais e período de rotação (em horas)
    const planetsData = [
      { name: "Mercúrio", a: 0.387, e: 0.2056, i: 7.005,  Ω: 48.331, ω: 29.124,  M0: 174.796, period: 87.97, rotationPeriod: 1407.6 },
      { name: "Vênus",   a: 0.723, e: 0.0068, i: 3.394,  Ω: 76.680, ω: 54.884,  M0: 50.115,  period: 224.70, rotationPeriod: -5832 },
      { name: "Terra",   a: 1.000, e: 0.0167, i: 0.000,  Ω: 0.000,  ω: 102.937, M0: 357.517, period: 365.256, rotationPeriod: 24 },
      { name: "Marte",   a: 1.524, e: 0.0934, i: 1.850,  Ω: 49.558, ω: 286.502, M0: 19.373,  period: 686.980, rotationPeriod: 24.6 },
      { name: "Nope",    a: 1.59,  e: 0.3,   i: 90.0,   Ω: 0.0,    ω: 0.0,     M0: 0.0,     period: 730, rotationPeriod: 26 },
      { name: "Júpiter", a: 5.203, e: 0.0489, i: 1.304,  Ω: 100.464, ω: 273.867, M0: 20.020, period: 4332.59, rotationPeriod: 9.9 },
      { name: "Saturno", a: 9.537, e: 0.0565, i: 2.485,  Ω: 113.665, ω: 339.392, M0: 317.020, period: 10759.22, rotationPeriod: 10.7 },
      { name: "Urano",   a: 19.191, e: 0.0463, i: 0.773,  Ω: 74.006,  ω: 96.998,  M0: 142.238, period: 30685.4, rotationPeriod: 17.2 },
      { name: "Netuno",  a: 30.07,  e: 0.0086, i: 1.770,  Ω: 131.784, ω: 272.846, M0: 256.228, period: 60190, rotationPeriod: 16.1 }
    ];
    
    // Dicionário com os arquivos de textura e displacement para cada planeta (cor branca para não alterar as texturas)
    const textureMap = {
      "Mercúrio": { texture: "mercury-texture.jpg", displacement: "mercury-displacement.jpg", fallbackColor: 0xffffff },
      "Vênus":   { texture: "venus-texture.jpg", displacement: "venus-displacement.jpg", fallbackColor: 0xffffff },
      "Terra":   { texture: "earth-texture.jpg", displacement: "earth-displacement.jpg", fallbackColor: 0xffffff },
      "Marte":   { texture: "mars-texture.jpg", displacement: "mars-displacement.jpg", fallbackColor: 0xffffff },
      "Nope":    { texture: "nope-texture.jpg", displacement: "nope-displacement.jpg", fallbackColor: 0xffffff },
      "Júpiter": { texture: "jupiter-texture.jpg", displacement: "jupiter-displacement.jpg", fallbackColor: 0xffffff },
      "Saturno": { texture: "saturn-texture.jpg", displacement: "saturn-displacement.jpg", fallbackColor: 0xffffff },
      "Urano":   { texture: "uranus-texture.jpg", displacement: "uranus-displacement.jpg", fallbackColor: 0xffffff },
      "Netuno":  { texture: "neptune-texture.jpg", displacement: "neptune-displacement.jpg", fallbackColor: 0xffffff }
    };
    
    // Criação do Sol com textura
    let sunGeometry = new THREE.SphereGeometry(10, 32, 32);
    let sunTexture = textureLoader.load("sun-texture.jpg");
    let sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
    let sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);
    
    // Adiciona uma PointLight ao Sol (única fonte de luz na cena)
    let sunLight = new THREE.PointLight(0xffffff, 2, 10000);
    sunLight.position.set(0, 0, 0);
    sun.add(sunLight);
    
    // Criação dos planetas e suas órbitas
    let planets = [];
    let nopeMesh, earthMesh;
    planetsData.forEach(planetData => {
      let size;
      switch(planetData.name) {
        case "Mercúrio": size = 2.5; break;
        case "Vênus":   size = 3;   break;
        case "Terra":   size = 3.5; break;
        case "Marte":   size = 3;   break;
        case "Nope":    size = 3;   break;
        case "Júpiter": size = 7;   break;
        case "Saturno": size = 6;   break;
        case "Urano":   size = 5;   break;
        case "Netuno":  size = 5;   break;
        default:        size = 3;
      }
      
      let segments;
      if (planetData.name === "Terra" || planetData.name === "Marte" || planetData.name === "Nope") {
        segments = 320; // alta resolução
      } else {
        segments = 16;  // baixa resolução (sem displacement)
      }
      
      let geometry = new THREE.SphereGeometry(size, segments, segments);
      let texData = textureMap[planetData.name];
      let texture = textureLoader.load(texData.texture);
      let displacement = textureLoader.load(texData.displacement);
      
      let material;
      if (planetData.name === "Terra" || planetData.name === "Marte" || planetData.name === "Nope") {
        material = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: texture,
          displacementMap: displacement,
          displacementScale: size * 0.2
        });
      } else {
        material = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: texture
        });
      }
      
      let mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      planetData.mesh = mesh;
      planets.push(planetData);
      
      if (planetData.name === "Nope") {
        nopeMesh = mesh;
      }
      if (planetData.name === "Terra") {
        earthMesh = mesh;
      }
      
      let orbitPoints = getOrbitPoints(planetData, 200);
      let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
      let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
      let orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
      scene.add(orbitLine);
    });
    
    // Criação da Lua da Terra (160 segmentos)
    let earthMoonOrbitGroup = new THREE.Group();
    // Note: Mantemos o grupo como filho de Earth para posicionar sua órbita,
    // mas compensaremos a rotação da Terra na atualização.
    earthMesh.add(earthMoonOrbitGroup);
    let earthMoonSize = earthMesh.geometry.parameters.radius / 4;
    let earthMoonGeometry = new THREE.SphereGeometry(earthMoonSize, 160, 160);
    let earthMoonTexture = textureLoader.load("earth-moon-texture.jpg");
    let earthMoonDisplacement = textureLoader.load("earth-moon-displacement.jpg");
    let earthMoonMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: earthMoonTexture,
      displacementMap: earthMoonDisplacement,
      displacementScale: earthMoonSize * 0.2
    });
    let earthMoonMesh = new THREE.Mesh(earthMoonGeometry, earthMoonMaterial);
    earthMoonMesh.position.set(8, 0, 0);
    earthMoonOrbitGroup.add(earthMoonMesh);
    let earthMoonPeriod = 10;
    
    // Criação da Lua de Nope (160 segmentos)
    let nopeMoonOrbitGroup = new THREE.Group();
    nopeMesh.add(nopeMoonOrbitGroup);
    let nopeMoonSize = nopeMesh.geometry.parameters.radius / 4;
    let nopeMoonGeometry = new THREE.SphereGeometry(nopeMoonSize, 160, 160);
    let nopeMoonTexture = textureLoader.load("nope-moon-texture.jpg");
    let nopeMoonDisplacement = textureLoader.load("nope-moon-displacement.jpg");
    let nopeMoonMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      map: nopeMoonTexture,
      displacementMap: nopeMoonDisplacement,
      displacementScale: nopeMoonSize * 0.2
    });
    let nopeMoonMesh = new THREE.Mesh(nopeMoonGeometry, nopeMoonMaterial);
    nopeMoonMesh.position.set(6, 0, 0);
    nopeMoonOrbitGroup.add(nopeMoonMesh);
    let nopeMoonPeriod = 10;
    
    // Removemos outras luzes: a única fonte será a PointLight do Sol.
    
    let lastFrameTime = performance.now();
    
    // Atualiza o alvo dos OrbitControls de forma dinâmica (foco interpolado entre Sol e Nope)
    function updateControlsTarget() {
      let d = camera.position.length();
      let normalizedZoom = 1 - (d - controls.minDistance) / (controls.maxDistance - controls.minDistance);
      normalizedZoom = THREE.MathUtils.clamp(normalizedZoom, 0, 1);
      
      let newTarget = new THREE.Vector3();
      if (normalizedZoom < 0.60) {
        newTarget.copy(sun.position);
      } else if (normalizedZoom > 0.95) {
        newTarget.copy(nopeMesh.position);
      } else {
        let t = (normalizedZoom - 0.60) / (0.95 - 0.60);
        newTarget.copy(sun.position).lerp(nopeMesh.position, t);
      }
      controls.target.lerp(newTarget, 0.1);
    }
    
    // Atualiza a rotação axial de um planeta (simulando o dia)
    function updatePlanetRotation(planet, time) {
      if (planet.rotationPeriod) {
        let rotationPeriodDays = planet.rotationPeriod / 24;
        let angle = time * (2 * Math.PI / rotationPeriodDays);
        planet.mesh.rotation.y = angle;
      }
    }
    
    function animate() {
      requestAnimationFrame(animate);
      let now = performance.now();
      let dt = (now - lastFrameTime) / 1000;
      lastFrameTime = now;
      
      simulationTime += dt * timeSpeed;
      let simDate = new Date(refDate.getTime() + simulationTime * 86400000);
      currentDateLabel.textContent = "Data Simulada: " + formatDate(simDate);
      
      // Atualiza posição orbital dos planetas
      planets.forEach(planet => {
        let pos = getPlanetPosition(planet, simulationTime);
        planet.mesh.position.copy(pos);
      });
      
      // Atualiza rotação axial (dia) de cada planeta
      planets.forEach(planet => {
        updatePlanetRotation(planet, simulationTime);
      });
      
      // Atualiza a rotação orbital das luas compensando a rotação do planeta pai
      
      // Para a Lua da Terra:
      let earthMoonAngle = (simulationTime * 2 * Math.PI / earthMoonPeriod) % (2 * Math.PI);
      // Compensa a rotação de Terra:
      earthMoonOrbitGroup.rotation.y = earthMoonAngle - earthMesh.rotation.y;
      
      // Para a Lua de Nope:
      let nopeMoonAngle = (simulationTime * 2 * Math.PI / nopeMoonPeriod) % (2 * Math.PI);
      nopeMoonOrbitGroup.rotation.y = nopeMoonAngle - nopeMesh.rotation.y;
      let tiltIncrement = deg2rad(15);
      let nopeMoonTilt = (simulationTime / nopeMoonPeriod) * tiltIncrement;
      nopeMoonOrbitGroup.rotation.x = nopeMoonTilt;
      
      updateControlsTarget();
      controls.update();
      renderer.render(scene, camera);
    }
    
    animate();
  })();
  </script>
</body>
</html>
