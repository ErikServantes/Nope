<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="UTF-8">
    <title>Nope v1.7 – Configuração de translação/rotação e parâmetros customizados</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; color: white; font-family: Arial, sans-serif; }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        max-height: 90vh;
        overflow-y: auto;
      }
      #ui h3 { margin-bottom: 5px; }
      .config-group { margin-bottom: 8px; }
      .config-group label { display: block; font-size: 14px; }
      .config-group input { width: 100%; font-size: 14px; padding: 2px; }
      .config-group small { font-size: 12px; color: #ccc; }
      /* Botões e controles já existentes */
      #speedControls { margin-bottom: 10px; }
      #speedControls button { width: 60px; height: 60px; font-size: 24px; }
    </style>
  </head>
  <body>
    <!-- Painel de Interface de Controle -->
    <div id="ui">
      <!-- Controles de Simulação (Velocidade e Data) -->
      <div id="speedControls">
        <div>
          <label for="speedRange">Velocidade (1 a 10): <span id="speedValue">1</span>x</label>
          <input type="range" id="speedRange" min="1" max="10" step="1" value="1">
        </div>
        <div style="margin-top:8px;">
          <button id="speedDown">–</button>
          <button id="speedUp">+</button>
        </div>
        <div style="margin-top:8px;">
          <label for="dateInput">Data:</label>
          <input type="date" id="dateInput">
        </div>
        <div style="margin-top:8px;">
          <span id="currentDate"></span>
        </div>
      </div>

      <!-- Painel de Configuração de "Nope" -->
      <div id="configPanel">
        <h3>Configuração de Nope</h3>
        <div class="config-group">
          <label for="nope_a">Semi-eixo maior (a):</label>
          <input type="number" id="nope_a" value="1.59" step="0.01">
          <small>(Em UA – Terra = 1.0 UA)</small>
        </div>
        <div class="config-group">
          <label for="nope_e">Excentricidade (e):</label>
          <input type="number" id="nope_e" value="0.3" step="0.01">
          <small>(Terra ~ 0.0167)</small>
        </div>
        <div class="config-group">
          <label for="nope_i">Inclinação orbital (i):</label>
          <input type="number" id="nope_i" value="90" step="1">
          <small>(Em graus – Terra = 0°)</small>
        </div>
        <div class="config-group">
          <label for="nope_Omega">Longitude do nodo ascendente (Ω):</label>
          <input type="number" id="nope_Omega" value="0.0" step="0.1">
        </div>
        <div class="config-group">
          <label for="nope_omega">Argumento do periélio (ω):</label>
          <input type="number" id="nope_omega" value="0.0" step="0.1">
        </div>
        <div class="config-group">
          <label for="nope_M0">Anomalia média inicial (M0):</label>
          <input type="number" id="nope_M0" value="0.0" step="0.1">
        </div>
        <div class="config-group">
          <label for="nope_period">Período orbital:</label>
          <input type="number" id="nope_period" value="730" step="1">
          <small>(Em dias)</small>
        </div>
        <div class="config-group">
          <label for="nope_rotationPeriod">Período de rotação:</label>
          <input type="number" id="nope_rotationPeriod" value="26" step="0.1">
          <small>(Em horas)</small>
        </div>
        <div class="config-group">
          <label for="nope_axialTilt">Inclinação axial:</label>
          <input type="number" id="nope_axialTilt" value="45" step="1">
          <small>(Em graus – Terra: 23.5°)</small>
        </div>

        <h3>Configuração da Lua de Nope</h3>
        <div class="config-group">
          <label for="nopeMoon_distance">Distância orbital:</label>
          <input type="number" id="nopeMoon_distance" value="4.5" step="0.1">
          <small>(Valor exato, relativo ao raio de Nope)</small>
        </div>
        <div class="config-group">
          <label for="nopeMoon_period">Período orbital da Lua:</label>
          <input type="number" id="nopeMoon_period" value="0.25" step="0.01">
          <small>(Em dias – 0.25 = 6 horas)</small>
        </div>
        <div class="config-group">
          <label for="nopeMoon_size">Tamanho da Lua:</label>
          <input type="number" id="nopeMoon_size" value="0.1875" step="0.0001">
          <small>(Valor exato – 1/16 do raio de Nope, se Nope = 3)</small>
        </div>
        <div class="config-group">
          <label for="nopeMoon_dispScale">Displacement Scale da Lua:</label>
          <input type="number" id="nopeMoon_dispScale" value="0.0047" step="0.0001">
        </div>
        <div class="config-group">
          <label for="nopeMoon_orbitTilt">Inclinação da órbita da Lua:</label>
          <input type="number" id="nopeMoon_orbitTilt" value="15" step="1">
          <small>(Em graus)</small>
        </div>
      </div>
    </div>

    <!-- Removido: Painel de Diagnóstico (antes à direita) -->

    <!-- Three.js e OrbitControls via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      (function(){
        // =============================
        // Cena, câmera, renderer e controles
        // =============================
        let scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 20000);
        camera.position.set(0, 200, 500);
        
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Apenas a luz do Sol será usada
        let textureLoader = new THREE.TextureLoader();
        
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 2000;
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth/window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // =============================
        // UI Elements – Controles de Simulação e Configuração
        // =============================
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const speedDown = document.getElementById('speedDown');
        const speedUp = document.getElementById('speedUp');
        const dateInput = document.getElementById('dateInput');
        const currentDateLabel = document.getElementById('currentDate');

        // Elementos do painel de configuração de Nope
        const nope_aInput = document.getElementById('nope_a');
        const nope_eInput = document.getElementById('nope_e');
        const nope_iInput = document.getElementById('nope_i');
        const nope_OmegaInput = document.getElementById('nope_Omega');
        const nope_omegaInput = document.getElementById('nope_omega');
        const nope_M0Input = document.getElementById('nope_M0');
        const nope_periodInput = document.getElementById('nope_period');
        const nope_rotationPeriodInput = document.getElementById('nope_rotationPeriod');
        const nope_axialTiltInput = document.getElementById('nope_axialTilt');

        // Elementos do painel de configuração da Lua de Nope
        const nopeMoon_distanceInput = document.getElementById('nopeMoon_distance');
        const nopeMoon_periodInput = document.getElementById('nopeMoon_period');
        const nopeMoon_sizeInput = document.getElementById('nopeMoon_size');
        const nopeMoon_dispScaleInput = document.getElementById('nopeMoon_dispScale');
        const nopeMoon_orbitTiltInput = document.getElementById('nopeMoon_orbitTilt');

        let speedSetting = parseInt(speedRange.value);
        speedValue.textContent = speedSetting;
        speedDown.addEventListener('click', () => {
          speedSetting = Math.max(1, speedSetting - 1);
          speedRange.value = speedSetting;
          speedValue.textContent = speedSetting;
        });
        speedUp.addEventListener('click', () => {
          speedSetting = Math.min(10, speedSetting + 1);
          speedRange.value = speedSetting;
          speedValue.textContent = speedSetting;
        });
        speedRange.addEventListener('input', function(){
          speedSetting = parseInt(this.value);
          speedValue.textContent = speedSetting;
        });
        
        const refDate = new Date();
        dateInput.value = formatDate(refDate);
        let simulationTime = 0; // em dias
        dateInput.addEventListener('change', function(){
          let newDate = new Date(this.value);
          simulationTime = (newDate - refDate)/86400000;
        });
        function formatDate(date) {
          let yyyy = date.getFullYear();
          let mm = String(date.getMonth()+1).padStart(2,'0');
          let dd = String(date.getDate()).padStart(2,'0');
          return `${yyyy}-${mm}-${dd}`;
        }
        
        function deg2rad(deg) { return deg * Math.PI/180; }
        function solveKepler(M, e, tolerance=1e-6) {
          let E = M, delta = 1;
          while(Math.abs(delta) > tolerance) {
            delta = (E - e*Math.sin(E) - M)/(1 - e*Math.cos(E));
            E = E - delta;
          }
          return E;
        }
        
        // =============================
        // Criação do Sol e sua luz
        // =============================
        let sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        let sunTexture = textureLoader.load("sun-texture.jpg");
        let sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
        let sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.castShadow = false;
        sun.receiveShadow = false;
        scene.add(sun);
        let sunLight = new THREE.PointLight(0xffffff, 2, 10000);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.1;
        sunLight.shadow.camera.far = 20000;
        sunLight.shadow.bias = -0.005;
        sunLight.position.set(0,0,0);
        sun.add(sunLight);
        let sunSurfaceGeometry = new THREE.SphereGeometry(10 * 1.005, 32, 32);
        let sunSurfaceTexture = textureLoader.load("sun-surface.png");
        let sunSurfaceMaterial = new THREE.MeshPhongMaterial({
          map: sunSurfaceTexture,
          transparent: true,
          opacity: 0.7,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5
        });
        let sunSurfaceLayer = new THREE.Mesh(sunSurfaceGeometry, sunSurfaceMaterial);
        sunSurfaceLayer.castShadow = false;
        sunSurfaceLayer.receiveShadow = false;
        sun.add(sunSurfaceLayer);
        
        // =============================
        // Dados dos planetas – Atualizamos "Nope" usando os valores do painel
        // =============================
        const planetsData = [
          { name:"Mercúrio", a:0.387, e:0.2056, i:7.005, Ω:48.331, ω:29.124, M0:174.796, period:87.97, rotationPeriod:1407.6 },
          { name:"Vênus",   a:0.723, e:0.0068, i:3.394, Ω:76.680, ω:54.884, M0:50.115, period:224.70, rotationPeriod:-5832 },
          { name:"Terra",   a:1.000, e:0.0167, i:0.000, Ω:0.000, ω:102.937, M0:357.517, period:365.256, rotationPeriod:24, axialTilt:45 },
          { name:"Marte",   a:1.524, e:0.0934, i:1.850, Ω:49.558, ω:286.502, M0:19.373, period:686.980, rotationPeriod:24.6 },
          // "Nope" terá seus parâmetros atualizados via painel:
          { name:"Nope",    a:parseFloat(nope_aInput.value), e:parseFloat(nope_eInput.value), i:parseFloat(nope_iInput.value),
            Ω:parseFloat(nope_OmegaInput.value), ω:parseFloat(nope_omegaInput.value), M0:parseFloat(nope_M0Input.value),
            period:parseFloat(nope_periodInput.value), rotationPeriod:parseFloat(nope_rotationPeriodInput.value),
            axialTilt:parseFloat(nope_axialTiltInput.value), size:3 },
          { name:"Júpiter", a:5.203, e:0.0489, i:1.304, Ω:100.464, ω:273.867, M0:20.020, period:4332.59, rotationPeriod:9.9 },
          { name:"Saturno", a:9.537, e:0.0565, i:2.485, Ω:113.665, ω:339.392, M0:317.020, period:10759.22, rotationPeriod:10.7 },
          { name:"Urano",   a:19.191, e:0.0463, i:0.773, Ω:74.006,  ω:96.998, M0:142.238, period:30685.4, rotationPeriod:17.2 },
          { name:"Netuno",  a:30.07,  e:0.0086, i:1.770, Ω:131.784, ω:272.846, M0:256.228, period:60190, rotationPeriod:16.1 }
        ];
        const textureMap = {
          "Mercúrio": { texture:"mercury-texture.jpg", displacement:"mercury-displacement.jpg", fallbackColor:0xffffff },
          "Vênus":   { texture:"venus-texture.jpg", displacement:"venus-displacement.jpg", fallbackColor:0xffffff },
          "Terra":   { texture:"earth-texture.jpg", displacement:"earth-displacement.jpg", fallbackColor:0xffffff },
          "Marte":   { texture:"mars-texture.jpg", displacement:"mars-displacement.jpg", fallbackColor:0xffffff },
          "Nope":    { texture:"nope-texture.jpg", displacement:"nope-displacement.jpg", fallbackColor:0xffffff },
          "Júpiter": { texture:"jupiter-texture.jpg", displacement:"jupiter-displacement.jpg", fallbackColor:0xffffff },
          "Saturno": { texture:"saturn-texture.jpg", displacement:"saturn-displacement.jpg", fallbackColor:0xffffff },
          "Urano":   { texture:"uranus-texture.jpg", displacement:"uranus-displacement.jpg", fallbackColor:0xffffff },
          "Netuno":  { texture:"neptune-texture.jpg", displacement:"neptune-displacement.jpg", fallbackColor:0xffffff }
        };
        
        let planets = [];
        let nopeMesh, earthMesh;
        planetsData.forEach(planetData => {
          let size;
          switch(planetData.name) {
            case "Mercúrio": size = 2.5; break;
            case "Vênus":   size = 3; break;
            case "Terra":   size = 3.5; break;
            case "Marte":   size = 3; break;
            case "Nope":    size = planetData.size; break;
            case "Júpiter": size = 7; break;
            case "Saturno": size = 6; break;
            case "Urano":   size = 5; break;
            case "Netuno":  size = 5; break;
            default:        size = 3;
          }
          planetData.size = size;
          let segments = (planetData.name==="Terra" || planetData.name==="Marte" || planetData.name==="Nope") ? 320 : 16;
          let geometry = new THREE.SphereGeometry(size, segments, segments);
          let texData = textureMap[planetData.name];
          let texture = textureLoader.load(texData.texture);
          let displacement = textureLoader.load(texData.displacement);
          // Para "Terra", "Marte" e "Nope" usamos displacement com escala reduzida
          let material = (planetData.name==="Terra" || planetData.name==="Marte" || planetData.name==="Nope") ?
              new THREE.MeshStandardMaterial({ color: 0xffffff, map: texture, displacementMap: displacement, displacementScale: size * 0.025 }) :
              new THREE.MeshStandardMaterial({ color: 0xffffff, map: texture });
          
          if(planetData.name==="Terra" || planetData.name==="Nope") {
            let pivot = new THREE.Group();
            let tiltGroup = new THREE.Group();
            pivot.add(tiltGroup);
            let mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            tiltGroup.add(mesh);
            // Para "Nope", ajustamos a inclinação compensando a posição orbital
            if(planetData.name==="Nope") {
              tiltGroup.rotation.z = deg2rad((planetData.axialTilt) - 90);
            } else {
              tiltGroup.rotation.z = deg2rad(planetData.axialTilt);
            }
            scene.add(pivot);
            planetData.pivot = pivot;
            planetData.tiltGroup = tiltGroup;
            planetData.mesh = mesh;
            if(planetData.name==="Nope") { nopeMesh = pivot; }
            if(planetData.name==="Terra") { earthMesh = pivot; }
          } else {
            let mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            planetData.mesh = mesh;
          }
          planets.push(planetData);
          
          let orbitPoints = (function(planet, numPoints=200){
            let pts = [];
            let a = planet.a, e = planet.e, i = deg2rad(planet.i),
                Ω = deg2rad(planet.Ω), ω = deg2rad(planet.ω);
            for(let j=0; j<=numPoints; j++){
              let f = 2*Math.PI*j/numPoints;
              let r = a*(1-e*e)/(1+e*Math.cos(f));
              let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Z = r*(Math.sin(ω+f)*Math.sin(i));
              let scale = 50;
              pts.push(new THREE.Vector3(X*scale, Z*scale, Y*scale));
            }
            return pts;
          })(planetData);
          let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
          let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
          let orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
          scene.add(orbitLine);
        });
        
        // =============================
        // Criação da Lua da Terra (mantida)
        // =============================
        let earthMoonOrbitGroup = new THREE.Group();
        scene.add(earthMoonOrbitGroup);
        let earthMoonSize = (earthMesh.children[0].children[0].geometry.parameters.radius)/4;
        let earthMoonGeometry = new THREE.SphereGeometry(earthMoonSize, 160, 160);
        let earthMoonTexture = textureLoader.load("earth-moon-texture.jpg");
        let earthMoonDisplacement = textureLoader.load("earth-moon-displacement.jpg");
        let earthMoonMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: earthMoonTexture,
          displacementMap: earthMoonDisplacement,
          displacementScale: earthMoonSize * 0.025,
          emissive: 0x444444,
          emissiveIntensity: 1
        });
        let earthMoonMesh = new THREE.Mesh(earthMoonGeometry, earthMoonMaterial);
        earthMoonMesh.castShadow = true;
        earthMoonMesh.receiveShadow = true;
        earthMoonMesh.position.set(8, 0, 0);
        earthMoonOrbitGroup.add(earthMoonMesh);
        
        // =============================
        // Criação da Lua de Nope – parâmetros vindos do painel de configuração
        // =============================
        let nopeMoonOrbitGroup = new THREE.Group();
        scene.add(nopeMoonOrbitGroup);
        // Calculamos o tamanho da Lua de Nope com base no valor exato informado
        let nopeMoonSize = parseFloat(nopeMoon_sizeInput.value);
        let nopeMoonGeometry = new THREE.SphereGeometry(nopeMoonSize, 160, 160);
        let nopeMoonTexture = textureLoader.load("nope-moon-texture.jpg");
        let nopeMoonDisplacement = textureLoader.load("nope-moon-displacement.jpg");
        let nopeMoonMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: nopeMoonTexture,
          displacementMap: nopeMoonDisplacement,
          displacementScale: parseFloat(nopeMoon_dispScaleInput.value),
          emissive: 0x444444,
          emissiveIntensity: 1
        });
        let nopeMoonMesh = new THREE.Mesh(nopeMoonGeometry, nopeMoonMaterial);
        nopeMoonMesh.castShadow = true;
        nopeMoonMesh.receiveShadow = true;
        // Posição orbital definida pelo valor exato do painel
        nopeMoonMesh.position.set(parseFloat(nopeMoon_distanceInput.value), 0, 0);
        nopeMoonOrbitGroup.add(nopeMoonMesh);
        
        // =============================
        // Camada de nuvens para "Nope"
        // =============================
        let nopeCloudsGeometry = new THREE.SphereGeometry(3 * 1.02, 320, 320);
        let nopeCloudsTexture = textureLoader.load("nope-clouds.png");
        let nopeCloudsMaterial = new THREE.MeshStandardMaterial({
          map: nopeCloudsTexture,
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
          side: THREE.DoubleSide
        });
        let nopeCloudsMesh = new THREE.Mesh(nopeCloudsGeometry, nopeCloudsMaterial);
        nopeCloudsMesh.receiveShadow = true;
        let nopeCloudsGroup = new THREE.Group();
        nopeCloudsGroup.add(nopeCloudsMesh);
        scene.add(nopeCloudsGroup);
        
        // =============================
        // Atualização do target dos controles (baseado na posição do Sol e de Nope)
        // =============================
        function updateControlsTarget() {
          let D = new THREE.Vector3().subVectors(nopeMesh.position, sun.position).normalize();
          let camOffset = new THREE.Vector3().subVectors(camera.position, sun.position);
          let projLength = camOffset.dot(D);
          let projectionPoint = sun.position.clone().add(D.clone().multiplyScalar(projLength));
          let vector2 = new THREE.Vector3().subVectors(camera.position, projectionPoint);
          let L = vector2.length();
          let t;
          if(L > 200) {
            t = 0;
          } else if(L < 50) {
            t = 1;
          } else {
            t = (200 - L) / 150;
          }
          let target = new THREE.Vector3().lerpVectors(sun.position, nopeMesh.position, t);
          controls.target.copy(target);
        }
        
        // =============================
        // Loop de Animação
        // =============================
        let lastFrameTime = performance.now();
        function animate() {
          requestAnimationFrame(animate);
          let now = performance.now();
          let dt = (now - lastFrameTime)/1000;
          lastFrameTime = now;
          
          // Atualiza simulação de tempo e data
          let minSpeedFactor = 365.256/3600;
          let maxSpeedFactor = 100 * 365.256/3600;
          let speedFactor = minSpeedFactor + ((speedSetting - 1)/9) * (maxSpeedFactor - minSpeedFactor);
          simulationTime += dt * speedFactor;
          let simDate = new Date(refDate.getTime() + simulationTime*86400000);
          currentDateLabel.textContent = "Data Simulada: " + formatDate(simDate);
          
          // Atualiza os parâmetros de "Nope" com base nos valores do painel de configuração
          // (Isso permite que, em tempo real, se alterem os valores e a simulação os use)
          let updatedNope = planetsData.find(p => p.name==="Nope");
          if(updatedNope) {
            updatedNope.a = parseFloat(nope_aInput.value);
            updatedNope.e = parseFloat(nope_eInput.value);
            updatedNope.i = parseFloat(nope_iInput.value);
            updatedNope.Ω = parseFloat(nope_OmegaInput.value);
            updatedNope.ω = parseFloat(nope_omegaInput.value);
            updatedNope.M0 = parseFloat(nope_M0Input.value);
            updatedNope.period = parseFloat(nope_periodInput.value);
            updatedNope.rotationPeriod = parseFloat(nope_rotationPeriodInput.value);
            updatedNope.axialTilt = parseFloat(nope_axialTiltInput.value);
          }
          
          // Atualiza posição e rotação dos planetas
          planets.forEach(planet => {
            let pos = (function(planet, time) {
              let a = planet.a, e = planet.e, i = deg2rad(planet.i),
                  Ω = deg2rad(planet.Ω), ω = deg2rad(planet.ω), M0 = deg2rad(planet.M0),
                  period = planet.period;
              let n = 2*Math.PI/period;
              let M = (M0 + n*time) % (2*Math.PI);
              let E = solveKepler(M, e);
              let f = 2*Math.atan2(Math.sqrt(1+e)*Math.sin(E/2), Math.sqrt(1-e)*Math.cos(E/2));
              let r = a*(1 - e*Math.cos(E));
              let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Z = r*(Math.sin(ω+f)*Math.sin(i));
              let scale = 50;
              return new THREE.Vector3(X*scale, Z*scale, Y*scale);
            })(planet, simulationTime);
            if(planet.pivot) {
              planet.pivot.position.copy(pos);
            } else {
              planet.mesh.position.copy(pos);
            }
          });
          planets.forEach(planet => {
            if(planet.rotationPeriod) {
              let rotationPeriodDays = planet.rotationPeriod/24;
              let angle = simulationTime * (2*Math.PI/rotationPeriodDays);
              if(planet.pivot && planet.tiltGroup) {
                if(planet.name==="Nope") {
                  let n = 2*Math.PI/planet.period;
                  let orbitalAngle = (n * simulationTime) % (2*Math.PI);
                  planet.tiltGroup.rotation.y = angle - orbitalAngle;
                } else {
                  planet.tiltGroup.rotation.y = angle;
                }
              } else {
                planet.mesh.rotation.y = angle;
              }
            }
          });
          
          // Atualiza posições das luas e nuvens
          earthMoonOrbitGroup.position.copy(earthMesh.position);
          nopeMoonOrbitGroup.position.copy(nopeMesh.position);
          let earthMoonAngle = (simulationTime * 2*Math.PI/10) % (2*Math.PI);
          earthMoonOrbitGroup.rotation.y = earthMoonAngle;
          let nopeMoonPeriod = parseFloat(nopeMoon_periodInput.value);
          let nopeMoonAngle = (simulationTime * 2*Math.PI / nopeMoonPeriod) % (2*Math.PI);
          nopeMoonOrbitGroup.rotation.y = nopeMoonAngle;
          // Atualiza inclinação da órbita da Lua de Nope conforme o valor do painel (convertendo para radianos)
          let tiltIncrement = deg2rad(parseFloat(nopeMoon_orbitTiltInput.value));
          let nopeMoonTilt = (simulationTime/10) * tiltIncrement;
          nopeMoonOrbitGroup.rotation.x = nopeMoonTilt;
          nopeCloudsGroup.position.copy(nopeMesh.position);
          
          updateControlsTarget();
          controls.update();
          renderer.render(scene, camera);
        }
        animate();
      })();
    </script>
  </body>
</html>
