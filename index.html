<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="UTF-8">
    <title>Nope v1.8</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; color: white; font-family: Arial, sans-serif; }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
      }
      #diagnostics {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0,0,0,0.7);
        padding: 8px;
        border-radius: 5px;
        font-size: 14px;
      }
      input, label, button { font-size: 14px; }
      #ui button { width: 60px; height: 60px; font-size: 24px; }
    </style>
  </head>
  <body>
    <!-- Interface de Controle -->
    <div id="ui">
      <div>
        <label for="speedRange">Velocidade (1 a 10): <span id="speedValue">1</span>x</label><br>
        <input type="range" id="speedRange" min="1" max="10" step="1" value="1">
      </div>
      <div style="margin-top:8px;">
        <button id="speedDown">–</button>
        <button id="speedUp">+</button>
      </div>
      <div style="margin-top:8px;">
        <label for="dateInput">Data:</label><br>
        <input type="date" id="dateInput">
      </div>
      <div style="margin-top:8px;">
        <span id="currentDate"></span>
      </div>
      <div style="margin-top:8px; font-size:12px;">
        (Use mouse ou toque para orbitar, dar zoom e pan)
      </div>
    </div>
    
    <!-- Diagnóstico: Zoom -->
    <div id="diagnostics">
      Zoom: <span id="zoomValue">0</span> units
    </div>
    
    <!-- Three.js e OrbitControls via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
      (function(){
        // Estado de zoom: 0 = Sol, 1 = Target1, 2 = Target2, 3 = Target3, 4 = Nope
        let currentZoomState = 0;
        
        // Thresholds para transição (zoom in)
        const thresholdsIn = [160, 140, 120, 100]; 
        // Thresholds para zoom out (os mesmos, invertidos)
        const thresholdsOut = [160, 140, 120, 100];
        
        // Duração da transição (não usaremos animação – mudanças são imediatas)
        // Assim, não há interpolação; a atualização será imediata.
        
        // Função para calcular os 5 targets (dinâmicos, pois o Sol e o Nope podem mover-se)
        function computeTargets() {
          let target0 = sun.position.clone();
          let target4 = nopeMesh.position.clone();
          let V = target4.clone().sub(target0);
          let target1 = target0.clone().add(V.clone().multiplyScalar(0.25));
          let target2 = target0.clone().add(V.clone().multiplyScalar(0.50));
          let target3 = target0.clone().add(V.clone().multiplyScalar(0.75));
          return [target0, target1, target2, target3, target4];
        }
        
        // Função para atualizar o zoom imediatamente, sem animação
        function updateZoomTransitions() {
          let targets = computeTargets(); // [target0, target1, target2, target3, target4]
          // Verifica o estado atual e aplica as condições
          if (currentZoomState === 0) { // Target = Sol
            if (camera.position.distanceTo(targets[0]) < thresholdsIn[0]) {
              // Muda para estado 1
              currentZoomState = 1;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[1]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[1]).add(dir.multiplyScalar(thresholdsIn[0]));
              controls.target.copy(targets[1]);
            }
          } else if (currentZoomState === 1) { // Target = target1
            let d = camera.position.distanceTo(targets[1]);
            if (d < thresholdsIn[1]) {
              currentZoomState = 2;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[2]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[2]).add(dir.multiplyScalar(thresholdsIn[1]));
              controls.target.copy(targets[2]);
            } else if (d > thresholdsOut[0]) {
              currentZoomState = 0;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[0]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[0]).add(dir.multiplyScalar(thresholdsOut[0]));
              controls.target.copy(targets[0]);
            }
          } else if (currentZoomState === 2) { // Target = target2
            let d = camera.position.distanceTo(targets[2]);
            if (d < thresholdsIn[2]) {
              currentZoomState = 3;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[3]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[3]).add(dir.multiplyScalar(thresholdsIn[2]));
              controls.target.copy(targets[3]);
            } else if (d > thresholdsOut[1]) {
              currentZoomState = 1;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[1]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[1]).add(dir.multiplyScalar(thresholdsOut[1]));
              controls.target.copy(targets[1]);
            }
          } else if (currentZoomState === 3) { // Target = target3
            let d = camera.position.distanceTo(targets[3]);
            if (d < thresholdsIn[3]) {
              currentZoomState = 4;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[4]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[4]).add(dir.multiplyScalar(thresholdsIn[3]));
              controls.target.copy(targets[4]);
            } else if (d > thresholdsOut[2]) {
              currentZoomState = 2;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[2]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[2]).add(dir.multiplyScalar(thresholdsOut[2]));
              controls.target.copy(targets[2]);
            }
          } else if (currentZoomState === 4) { // Target = Nope
            if (camera.position.distanceTo(targets[4]) > thresholdsOut[3]) {
              currentZoomState = 3;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[3]);
              if(dir.length() === 0) dir.set(1,0,0);
              dir.normalize();
              camera.position.copy(targets[3]).add(dir.multiplyScalar(thresholdsOut[3]));
              controls.target.copy(targets[3]);
            }
          }
        }
        
        // ===============================
        // (Demais funções e dados permanecem iguais)
        
        function updatePlanetRotation(planet, time) {
          if(planet.rotationPeriod) {
            let rotationPeriodDays = planet.rotationPeriod/24;
            let angle = time * (2*Math.PI/rotationPeriodDays);
            if(planet.pivot && planet.tiltGroup) {
              planet.tiltGroup.rotation.y = angle;
            } else {
              planet.mesh.rotation.y = angle;
            }
          }
        }
        
        const minSpeedFactor = 365.256/3600;
        const maxSpeedFactor = 100 * 365.256/3600;
        
        let lastFrameTime = performance.now();
        
        // ===============================
        // Criação dos objetos – Sol, planetas, luas, nuvens – (mesmo que antes)
        // [O código a seguir permanece inalterado; veja a versão anterior para detalhes completos]
        
        // Criação do Sol
        let sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        let sunTexture = textureLoader.load("sun-texture.jpg");
        let sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
        let sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        let sunLight = new THREE.PointLight(0xffffff, 2, 10000);
        sunLight.position.set(0,0,0);
        sun.add(sunLight);
        
        // Camada extra do Sol
        let sunSurfaceGeometry = new THREE.SphereGeometry(10 * 1.005, 32, 32);
        let sunSurfaceTexture = textureLoader.load("sun-surface.png");
        let sunSurfaceMaterial = new THREE.MeshPhongMaterial({
          map: sunSurfaceTexture,
          transparent: true,
          opacity: 0.7,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5
        });
        let sunSurfaceLayer = new THREE.Mesh(sunSurfaceGeometry, sunSurfaceMaterial);
        sun.add(sunSurfaceLayer);
        
        // Criação dos planetas
        let planets = [];
        let nopeMesh, earthMesh;
        planetsData.forEach(planetData => {
          let size;
          switch(planetData.name) {
            case "Mercúrio": size = 2.5; break;
            case "Vênus":   size = 3; break;
            case "Terra":   size = 3.5; break;
            case "Marte":   size = 3; break;
            case "Nope":    size = 3; break;
            case "Júpiter": size = 7; break;
            case "Saturno": size = 6; break;
            case "Urano":   size = 5; break;
            case "Netuno":  size = 5; break;
            default:        size = 3;
          }
          planetData.size = size;
          let segments = (planetData.name==="Terra" || planetData.name==="Marte" || planetData.name==="Nope")
                         ? 320 : 16;
          let geometry = new THREE.SphereGeometry(size, segments, segments);
          let texData = textureMap[planetData.name];
          let texture = textureLoader.load(texData.texture);
          let displacement = textureLoader.load(texData.displacement);
          let material;
          if(planetData.name==="Terra" || planetData.name==="Marte" || planetData.name==="Nope") {
            material = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              map: texture,
              displacementMap: displacement,
              displacementScale: size * 0.05
            });
          } else {
            material = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              map: texture
            });
          }
          if(planetData.name==="Terra" || planetData.name==="Nope") {
            let pivot = new THREE.Group();
            let tiltGroup = new THREE.Group();
            pivot.add(tiltGroup);
            let mesh = new THREE.Mesh(geometry, material);
            tiltGroup.add(mesh);
            tiltGroup.rotation.z = deg2rad(planetData.axialTilt || 45);
            scene.add(pivot);
            planetData.pivot = pivot;
            planetData.tiltGroup = tiltGroup;
            planetData.mesh = mesh;
            if(planetData.name==="Nope") {
              nopeMesh = pivot;
              window.nopeTiltGroup = tiltGroup;
            }
            if(planetData.name==="Terra") {
              earthMesh = pivot;
            }
          } else {
            let mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            planetData.mesh = mesh;
          }
          planets.push(planetData);
          let orbitPoints = getOrbitPoints(planetData, 200);
          let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
          let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
          let orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
          scene.add(orbitLine);
        });
        
        // Criação da Lua da Terra
        let earthMoonOrbitGroup = new THREE.Group();
        scene.add(earthMoonOrbitGroup);
        let earthMoonSize = (earthMesh.children[0].children[0].geometry.parameters.radius)/4;
        let earthMoonGeometry = new THREE.SphereGeometry(earthMoonSize, 160, 160);
        let earthMoonTexture = textureLoader.load("earth-moon-texture.jpg");
        let earthMoonDisplacement = textureLoader.load("earth-moon-displacement.jpg");
        let earthMoonMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: earthMoonTexture,
          displacementMap: earthMoonDisplacement,
          displacementScale: earthMoonSize * 0.05,
          emissive: 0x444444,
          emissiveIntensity: 1
        });
        let earthMoonMesh = new THREE.Mesh(earthMoonGeometry, earthMoonMaterial);
        earthMoonMesh.position.set(8, 0, 0);
        earthMoonOrbitGroup.add(earthMoonMesh);
        let earthMoonPeriod = 10;
        
        // Criação da Lua de Nope
        let nopeMoonOrbitGroup = new THREE.Group();
        scene.add(nopeMoonOrbitGroup);
        let nopeMoonSize = (nopeMesh.children[0].children[0].geometry.parameters.radius)/4;
        let nopeMoonGeometry = new THREE.SphereGeometry(nopeMoonSize, 160, 160);
        let nopeMoonTexture = textureLoader.load("nope-moon-texture.jpg");
        let nopeMoonDisplacement = textureLoader.load("nope-moon-displacement.jpg");
        let nopeMoonMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          map: nopeMoonTexture,
          displacementMap: nopeMoonDisplacement,
          displacementScale: nopeMoonSize * 0.05,
          emissive: 0x444444,
          emissiveIntensity: 1
        });
        let nopeMoonMesh = new THREE.Mesh(nopeMoonGeometry, nopeMoonMaterial);
        nopeMoonMesh.position.set(6, 0, 0);
        nopeMoonOrbitGroup.add(nopeMoonMesh);
        let nopeMoonPeriod = 10;
        
        // Camada de nuvens para "Nope"
        let nopeCloudsGeometry = new THREE.SphereGeometry(3 * 1.02, 320, 320);
        let nopeCloudsTexture = textureLoader.load("nope-clouds.png");
        let nopeCloudsMaterial = new THREE.MeshStandardMaterial({
          map: nopeCloudsTexture,
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
          side: THREE.DoubleSide
        });
        let nopeCloudsMesh = new THREE.Mesh(nopeCloudsGeometry, nopeCloudsMaterial);
        let nopeCloudsGroup = new THREE.Group();
        nopeCloudsGroup.add(nopeCloudsMesh);
        scene.add(nopeCloudsGroup);
        
        // ===============================
        // Atualiza as transições de zoom (sem animação – mudança imediata)
        function updateZoomTransitions() {
          let targets = computeTargets(); // [target0, target1, target2, target3, target4]
          if (currentZoomState === 0) {
            if (camera.position.distanceTo(targets[0]) < 160) {
              currentZoomState = 1;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[1]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[1]).add(dir.multiplyScalar(160));
              controls.target.copy(targets[1]);
            }
          } else if (currentZoomState === 1) {
            let d = camera.position.distanceTo(targets[1]);
            if (d < 140) {
              currentZoomState = 2;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[2]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[2]).add(dir.multiplyScalar(140));
              controls.target.copy(targets[2]);
            } else if (d > 160) {
              currentZoomState = 0;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[0]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[0]).add(dir.multiplyScalar(160));
              controls.target.copy(targets[0]);
            }
          } else if (currentZoomState === 2) {
            let d = camera.position.distanceTo(targets[2]);
            if (d < 120) {
              currentZoomState = 3;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[3]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[3]).add(dir.multiplyScalar(120));
              controls.target.copy(targets[3]);
            } else if (d > 140) {
              currentZoomState = 1;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[1]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[1]).add(dir.multiplyScalar(140));
              controls.target.copy(targets[1]);
            }
          } else if (currentZoomState === 3) {
            let d = camera.position.distanceTo(targets[3]);
            if (d < 100) {
              currentZoomState = 4;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[4]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[4]).add(dir.multiplyScalar(100));
              controls.target.copy(targets[4]);
            } else if (d > 120) {
              currentZoomState = 2;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[2]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[2]).add(dir.multiplyScalar(120));
              controls.target.copy(targets[2]);
            }
          } else if (currentZoomState === 4) {
            if (camera.position.distanceTo(targets[4]) > 100) {
              currentZoomState = 3;
              let dir = new THREE.Vector3().subVectors(camera.position, targets[3]);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(targets[3]).add(dir.multiplyScalar(100));
              controls.target.copy(targets[3]);
            }
          }
        }
        
        // ===============================
        // Função para computar os 5 targets do vetor Sol–Nope
        function computeTargets() {
          let target0 = sun.position.clone();
          let target4 = nopeMesh.position.clone();
          let V = target4.clone().sub(target0);
          let target1 = target0.clone().add(V.clone().multiplyScalar(0.25));
          let target2 = target0.clone().add(V.clone().multiplyScalar(0.50));
          let target3 = target0.clone().add(V.clone().multiplyScalar(0.75));
          return [target0, target1, target2, target3, target4];
        }
        
        // ===============================
        // Demais funções (rotação dos planetas, etc.)
        function updatePlanetRotation(planet, time) {
          if(planet.rotationPeriod) {
            let rotationPeriodDays = planet.rotationPeriod/24;
            let angle = time * (2*Math.PI/rotationPeriodDays);
            if(planet.pivot && planet.tiltGroup) {
              planet.tiltGroup.rotation.y = angle;
            } else {
              planet.mesh.rotation.y = angle;
            }
          }
        }
        
        const minSpeedFactor = 365.256/3600;
        const maxSpeedFactor = 100 * 365.256/3600;
        let lastFrameTime = performance.now();
        
        function animate() {
          requestAnimationFrame(animate);
          let now = performance.now();
          let dt = (now - lastFrameTime)/1000;
          lastFrameTime = now;
          let speedFactor = minSpeedFactor + ((speedSetting - 1)/9) * (maxSpeedFactor - minSpeedFactor);
          simulationTime += dt * speedFactor;
          let simDate = new Date(refDate.getTime() + simulationTime*86400000);
          currentDateLabel.textContent = "Data Simulada: " + formatDate(simDate);
          
          // Atualiza posição orbital dos planetas
          planets.forEach(planet => {
            let pos = getPlanetPosition(planet, simulationTime);
            if(planet.pivot) {
              planet.pivot.position.copy(pos);
            } else {
              planet.mesh.position.copy(pos);
            }
          });
          
          // Atualiza rotação dos planetas
          planets.forEach(planet => {
            updatePlanetRotation(planet, simulationTime);
          });
          
          // Atualiza grupos das luas
          earthMoonOrbitGroup.position.copy(earthMesh.position);
          nopeMoonOrbitGroup.position.copy(nopeMesh.position);
          let earthMoonAngle = (simulationTime * 2*Math.PI/10) % (2*Math.PI);
          earthMoonOrbitGroup.rotation.y = earthMoonAngle;
          let nopeMoonAngle = (simulationTime * 2*Math.PI/10) % (2*Math.PI);
          nopeMoonOrbitGroup.rotation.y = nopeMoonAngle;
          let tiltIncrement = deg2rad(15);
          let nopeMoonTilt = (simulationTime/10) * tiltIncrement;
          nopeMoonOrbitGroup.rotation.x = nopeMoonTilt;
          
          // Atualiza nuvens de Nope
          nopeCloudsGroup.position.copy(nopeMesh.position);
          let nopePivotRotation = window.nopeTiltGroup ? window.nopeTiltGroup.rotation.y : 0;
          nopeCloudsGroup.rotation.y = nopePivotRotation/10;
          
          // Atualiza transições de zoom (imediatas, sem animação)
          updateZoomTransitions();
          
          controls.update();
          renderer.render(scene, camera);
        }
        
        animate();
      })();
    </script>
  </body>
</html>
