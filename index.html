<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="UTF-8">
    <title>Nope v1.5 – Sombras e Lua de Nope mais Rápida</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; color: white; font-family: Arial, sans-serif; }
      /* Interface de Controle Original */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
      }
      #diagnostics {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.7);
        padding: 8px;
        border-radius: 5px;
        font-size: 14px;
      }
      input, label, button { font-size: 14px; }
      #ui button { width: 60px; height: 60px; font-size: 24px; }
      
      /* Menu flutuante para edição dos planetas */
      #planetMenu {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 300;
        background: rgba(0,0,0,0.85);
        padding: 10px;
        border-radius: 5px;
        max-height: 90vh;
        overflow-y: auto;
        width: 300px;
      }
      #planetMenu h2 {
        margin-top: 0;
        font-size: 18px;
        text-align: center;
      }
      .planetEntry {
        border: 1px solid #444;
        margin-bottom: 10px;
        padding: 5px;
        border-radius: 3px;
      }
      .planetEntry h3 {
        margin: 5px 0;
        cursor: pointer;
      }
      .planetParams {
        font-size: 12px;
        display: none;
      }
      .planetParams label {
        display: block;
        margin: 2px 0;
      }
      .planetParams input {
        width: 90%;
        padding: 2px;
        margin-bottom: 4px;
        background: #222;
        border: 1px solid #555;
        color: white;
      }
    </style>
    <!-- Incluindo PapaParse para carregar CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  </head>
  <body>
    <!-- Interface de Controle Original -->
    <div id="ui">
      <div>
        <label for="speedRange">Velocidade (1 a 10): <span id="speedValue">1</span>x</label><br>
        <input type="range" id="speedRange" min="1" max="10" step="1" value="1">
      </div>
      <div style="margin-top:8px;">
        <button id="speedDown">–</button>
        <button id="speedUp">+</button>
      </div>
      <div style="margin-top:8px;">
        <label for="dateInput">Data:</label><br>
        <input type="date" id="dateInput">
      </div>
      <div style="margin-top:8px;">
        <span id="currentDate"></span>
      </div>
      <div style="margin-top:8px; font-size:12px;">
        (Use mouse ou toque para orbitar, dar zoom e pan)
      </div>
    </div>
    
    <!-- Diagnóstico: Zoom -->
    <div id="diagnostics">
      Zoom: <span id="zoomValue">0</span> units
    </div>
    
    <!-- Menu flutuante para edição dos planetas -->
    <div id="planetMenu">
      <h2>Edição dos Planetas</h2>
      <!-- As entradas para cada planeta serão adicionadas dinamicamente -->
    </div>
    
    <!-- Three.js e OrbitControls via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
      (function(){
        // Fator de escala: 1UA = 16 Terras; considerando que o tamanho de uma Terra é 3.5, 16*3.5 = 56.
        const distanceScale = 56;
        // O Sol terá um raio de 8 Terras, ou seja, 8 * 3.5 = 28.
        const sunRadius = 28;
        
        // =============================
        // Cena, câmera, renderer e controles
        // =============================
        let scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 20000);
        camera.position.set(0, 200, 500);
        
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        let textureLoader = new THREE.TextureLoader();
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 2000;
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth/window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // =============================
        // Variáveis de simulação e tempo
        // =============================
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const speedDown = document.getElementById('speedDown');
        const speedUp = document.getElementById('speedUp');
        const dateInput = document.getElementById('dateInput');
        const currentDateLabel = document.getElementById('currentDate');
        const zoomValue = document.getElementById('zoomValue');
        
        let speedSetting = parseInt(speedRange.value);
        speedValue.textContent = speedSetting;
        speedDown.addEventListener('click', () => {
          speedSetting = Math.max(1, speedSetting - 1);
          speedRange.value = speedSetting;
          speedValue.textContent = speedSetting;
        });
        speedUp.addEventListener('click', () => {
          speedSetting = Math.min(10, speedSetting + 1);
          speedRange.value = speedSetting;
          speedValue.textContent = speedSetting;
        });
        speedRange.addEventListener('input', function(){
          speedSetting = parseInt(this.value);
          speedValue.textContent = speedSetting;
        });
        
        const refDate = new Date();
        dateInput.value = formatDate(refDate);
        let simulationTime = 0; // em dias
        dateInput.addEventListener('change', function(){
          let newDate = new Date(this.value);
          simulationTime = (newDate - refDate)/86400000;
        });
        function formatDate(date) {
          let yyyy = date.getFullYear();
          let mm = String(date.getMonth()+1).padStart(2,'0');
          let dd = String(date.getDate()).padStart(2,'0');
          return `${yyyy}-${mm}-${dd}`;
        }
        
        function deg2rad(deg) { return deg * Math.PI/180; }
        function solveKepler(M, e, tolerance=1e-6) {
          let E = M, delta = 1;
          while(Math.abs(delta) > tolerance) {
            delta = (E - e*Math.sin(E) - M)/(1 - e*Math.cos(E));
            E = E - delta;
          }
          return E;
        }
        
        // =============================
        // Criação do Sol (ajustado para tamanho de 8 Terras)
        // =============================
        let sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
        let sunTexture = textureLoader.load("sun-texture.jpg");
        let sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
        let sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.castShadow = false;
        sun.receiveShadow = false;
        scene.add(sun);
        let sunLight = new THREE.PointLight(0xffffff, 2, 10000);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.1;
        sunLight.shadow.camera.far = 20000;
        sunLight.shadow.bias = -0.005;
        sunLight.position.set(0,0,0);
        sun.add(sunLight);
        let sunSurfaceGeometry = new THREE.SphereGeometry(sunRadius * 1.005, 32, 32);
        let sunSurfaceTexture = textureLoader.load("sun-surface.png");
        let sunSurfaceMaterial = new THREE.MeshPhongMaterial({
          map: sunSurfaceTexture,
          transparent: true,
          opacity: 0.7,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5
        });
        let sunSurfaceLayer = new THREE.Mesh(sunSurfaceGeometry, sunSurfaceMaterial);
        sunSurfaceLayer.castShadow = false;
        sunSurfaceLayer.receiveShadow = false;
        sun.add(sunSurfaceLayer);
        
        // =============================
        // Carregamento dos CSVs (Planets.csv e Moons.csv)
        // =============================
        let planetsData = [];
        let moonsData = [];
        let planetsLoaded = false, moonsLoaded = false;
        
        Papa.parse("Planets.csv", {
          download: true,
          header: true,
          complete: function(results) {
            planetsData = results.data;
            planetsLoaded = true;
            checkDataLoaded();
          },
          error: function(err) {
            console.error("Erro ao carregar Planets.csv:", err);
          }
        });
        
        Papa.parse("Moons.csv", {
          download: true,
          header: true,
          complete: function(results) {
            moonsData = results.data;
            moonsLoaded = true;
            checkDataLoaded();
          },
          error: function(err) {
            console.error("Erro ao carregar Moons.csv:", err);
          }
        });
        
        function checkDataLoaded() {
          if (planetsLoaded && moonsLoaded) {
            initPlanets();
            createPlanetMenu();
          }
        }
        
        // =============================
        // Função para criar planetas e luas a partir dos CSVs
        // =============================
        function initPlanets() {
          planetsData.forEach(function(planetData) {
            // Converter valores numéricos
            planetData.semi_major_axis = parseFloat(planetData.semi_major_axis);
            planetData.eccentricity = parseFloat(planetData.eccentricity);
            planetData.inclination = parseFloat(planetData.inclination);
            planetData.ascending_node = parseFloat(planetData.ascending_node);
            planetData.argument_of_periapsis = parseFloat(planetData.argument_of_periapsis);
            planetData.mean_anomaly = parseFloat(planetData.mean_anomaly);
            planetData.orbital_period = parseFloat(planetData.orbital_period);
            planetData.rotation_period = parseFloat(planetData.rotation_period);
            if(planetData.axial_tilt) planetData.axial_tilt = parseFloat(planetData.axial_tilt);
            planetData.size = parseFloat(planetData.size);
            planetData.segments = parseInt(planetData.segments);
            
            // Para maior detalhe em Terra, Marte e Nope, usamos os segmentos do CSV; senão, 16.
            let segments = (planetData.name === "Terra" || planetData.name === "Marte" || planetData.name === "Nope") ? planetData.segments : 16;
            let geometry = new THREE.SphereGeometry(planetData.size, segments, segments);
            let texture = textureLoader.load(planetData.texture_file);
            let displacement = textureLoader.load(planetData.displacement_file);
            let material;
            if (planetData.name === "Terra" || planetData.name === "Marte" || planetData.name === "Nope") {
              material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                map: texture,
                displacementMap: displacement,
                displacementScale: planetData.size * 0.025
              });
            } else {
              material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                map: texture
              });
            }
            let mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            // Geramos um ângulo aleatório e armazenamos em planetData para uso posterior
            let angle = Math.random() * Math.PI * 2;
            planetData.angle = angle;
            let distance = planetData.semi_major_axis * distanceScale;
            mesh.position.set(Math.cos(angle) * distance, 0, Math.sin(angle) * distance);
            scene.add(mesh);
            planetData.mesh = mesh;
            
            // Criação da linha de órbita
            let orbitPoints = [];
            let numPoints = 200;
            let a = planetData.semi_major_axis;
            let e = planetData.eccentricity;
            let i = deg2rad(planetData.inclination);
            let Ω = deg2rad(planetData.ascending_node);
            let ω = deg2rad(planetData.argument_of_periapsis);
            for(let j=0; j<=numPoints; j++){
              let f = 2*Math.PI*j/numPoints;
              let r = a*(1-e*e)/(1+e*Math.cos(f));
              let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
              let Z = r*(Math.sin(ω+f)*Math.sin(i));
              orbitPoints.push(new THREE.Vector3(X*distanceScale, Z*distanceScale, Y*distanceScale));
            }
            let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
            let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
            let orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
            scene.add(orbitLine);
            planetData.orbitLine = orbitLine;
          });
          
          // Criação das luas associadas aos planetas
          moonsData.forEach(function(moonData) {
            moonData.planet_id = parseInt(moonData.planet_id);
            moonData.orbit_distance = parseFloat(moonData.orbit_distance);
            moonData.orbital_eccentricity = parseFloat(moonData.orbital_eccentricity);
            moonData.orbital_inclination = parseFloat(moonData.orbital_inclination);
            moonData.orbital_period = parseFloat(moonData.orbital_period);
            moonData.rotation_period = parseFloat(moonData.rotation_period);
            moonData.size = parseFloat(moonData.size);
            moonData.segments = parseInt(moonData.segments);
            
            // Procura o planeta correspondente
            let planet = planetsData.find(p => parseInt(p.id) === moonData.planet_id);
            if(planet && planet.mesh){
              let geometry = new THREE.SphereGeometry(moonData.size, moonData.segments, moonData.segments);
              let texture = textureLoader.load(moonData.texture_file);
              let displacement = textureLoader.load(moonData.displacement_file);
              let material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                map: texture,
                displacementMap: displacement,
                displacementScale: moonData.size * 0.025
              });
              let moonMesh = new THREE.Mesh(geometry, material);
              moonMesh.castShadow = true;
              moonMesh.receiveShadow = true;
              // Posiciona a lua relativamente ao planeta (mantemos o deslocamento definido no CSV)
              let moonPos = new THREE.Vector3().copy(planet.mesh.position).add(new THREE.Vector3(moonData.orbit_distance, 0, 0));
              moonMesh.position.copy(moonPos);
              scene.add(moonMesh);
              moonData.mesh = moonMesh;
            }
          });
        }
        
        // =============================
        // Função para atualizar um planeta quando seus parâmetros são alterados
        // =============================
        function updatePlanet(planetData) {
          let distance = planetData.semi_major_axis * distanceScale;
          planetData.mesh.position.set(Math.cos(planetData.angle) * distance, 0, Math.sin(planetData.angle) * distance);
          // Atualiza a linha de órbita: remove a antiga e recria uma nova
          if (planetData.orbitLine) {
            scene.remove(planetData.orbitLine);
          }
          let orbitPoints = [];
          let numPoints = 200;
          let a = planetData.semi_major_axis;
          let e = planetData.eccentricity;
          let i = deg2rad(planetData.inclination);
          let Ω = deg2rad(planetData.ascending_node);
          let ω = deg2rad(planetData.argument_of_periapsis);
          for(let j=0; j<=numPoints; j++){
            let f = 2*Math.PI*j/numPoints;
            let r = a*(1-e*e)/(1+e*Math.cos(f));
            let X = r*(Math.cos(Ω)*Math.cos(ω+f)-Math.sin(Ω)*Math.sin(ω+f)*Math.cos(i));
            let Y = r*(Math.sin(Ω)*Math.cos(ω+f)+Math.cos(Ω)*Math.sin(ω+f)*Math.cos(i));
            let Z = r*(Math.sin(ω+f)*Math.sin(i));
            orbitPoints.push(new THREE.Vector3(X*distanceScale, Z*distanceScale, Y*distanceScale));
          }
          let orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
          let orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
          let newOrbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
          scene.add(newOrbitLine);
          planetData.orbitLine = newOrbitLine;
        }
        
        // =============================
        // Cria o menu flutuante de edição dos planetas
        // =============================
        function createPlanetMenu() {
          const menu = document.getElementById("planetMenu");
          menu.innerHTML = "<h2>Edição dos Planetas</h2>";
          planetsData.forEach(function(planetData) {
            let entry = document.createElement("div");
            entry.className = "planetEntry";
            
            // Cabeçalho: nome do planeta (clicável para expandir/ocultar os parâmetros)
            let header = document.createElement("h3");
            header.textContent = planetData.name;
            header.addEventListener("click", function() {
              let paramsDiv = entry.querySelector(".planetParams");
              paramsDiv.style.display = paramsDiv.style.display === "none" ? "block" : "none";
            });
            entry.appendChild(header);
            
            // Container com os parâmetros editáveis
            let params = document.createElement("div");
            params.className = "planetParams";
            params.style.display = "none";
            
            function createField(labelText, fieldName, step = 0.1) {
              let labelElem = document.createElement("label");
              labelElem.textContent = labelText + ": ";
              let input = document.createElement("input");
              input.type = "number";
              input.step = step;
              input.value = planetData[fieldName];
              input.addEventListener("change", function() {
                planetData[fieldName] = parseFloat(this.value);
                updatePlanet(planetData);
              });
              labelElem.appendChild(input);
              return labelElem;
            }
            
            params.appendChild(createField("Semi-eixo", "semi_major_axis", 0.01));
            params.appendChild(createField("Excentricidade", "eccentricity", 0.001));
            params.appendChild(createField("Inclinação", "inclination", 0.1));
            params.appendChild(createField("Nó Asc.", "ascending_node", 0.1));
            params.appendChild(createField("Arg. Periapsis", "argument_of_periapsis", 0.1));
            params.appendChild(createField("Anomalia", "mean_anomaly", 0.1));
            params.appendChild(createField("Período Orbital", "orbital_period", 0.1));
            params.appendChild(createField("Período Rotação", "rotation_period", 0.1));
            params.appendChild(createField("Inclinação Axial", "axial_tilt", 0.1));
            params.appendChild(createField("Tamanho", "size", 0.1));
            
            entry.appendChild(params);
            menu.appendChild(entry);
          });
        }
        
        // =============================
        // Loop de animação
        // =============================
        let lastFrameTime = performance.now();
        function animate() {
          requestAnimationFrame(animate);
          let now = performance.now();
          let dt = (now - lastFrameTime) / 1000;
          lastFrameTime = now;
          
          let minSpeedFactor = 365.256 / 3600;
          let maxSpeedFactor = 100 * 365.256 / 3600;
          let speedFactor = minSpeedFactor + ((speedSetting - 1) / 9) * (maxSpeedFactor - minSpeedFactor);
          simulationTime += dt * speedFactor;
          let simDate = new Date(refDate.getTime() + simulationTime * 86400000);
          currentDateLabel.textContent = "Data Simulada: " + formatDate(simDate);
          
          // Rotaciona os planetas (simples rotação em torno do próprio eixo)
          planetsData.forEach(function(planetData) {
            if(planetData.mesh) {
              planetData.mesh.rotation.y += 0.01;
            }
          });
          
          controls.target.copy(sun.position);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();
      })();
    </script>
  </body>
</html>
