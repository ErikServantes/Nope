<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="UTF-8">
    <title>Nope v1.7</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; color: white; font-family: Arial, sans-serif; }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 5px;
      }
      #diagnostics {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 100;
        background: rgba(0,0,0,0.7);
        padding: 8px;
        border-radius: 5px;
        font-size: 14px;
      }
      input, label, button { font-size: 14px; }
      #ui button { width: 60px; height: 60px; font-size: 24px; }
    </style>
  </head>
  <body>
    <!-- Interface de Controle -->
    <div id="ui">
      <div>
        <label for="speedRange">Velocidade (1 a 10): <span id="speedValue">1</span>x</label><br>
        <input type="range" id="speedRange" min="1" max="10" step="1" value="1">
      </div>
      <div style="margin-top:8px;">
        <button id="speedDown">–</button>
        <button id="speedUp">+</button>
      </div>
      <div style="margin-top:8px;">
        <label for="dateInput">Data:</label><br>
        <input type="date" id="dateInput">
      </div>
      <div style="margin-top:8px;">
        <span id="currentDate"></span>
      </div>
      <div style="margin-top:8px; font-size:12px;">
        (Use mouse ou toque para orbitar, dar zoom e pan)
      </div>
    </div>
    
    <!-- Diagnóstico: Zoom -->
    <div id="diagnostics">
      Zoom: <span id="zoomValue">0</span> units
    </div>
    
    <!-- Three.js e OrbitControls via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
      (function(){
        // Estado de zoom: 0 = Sol, 1 = Target1, 2 = Target2, 3 = Target3, 4 = Nope.
        let currentZoomState = 0;
        // Thresholds para zoom in (se distância ao target atual for menor que):
        const thresholdsIn = [160, 140, 120, 100]; 
        // Thresholds para zoom out (se distância for maior que):
        const thresholdsOut = [160, 140, 120, 100];
        
        // Como não haverá transição animada, as mudanças são imediatas.
        function updateZoomTransitions() {
          // Recalcula os 5 targets a partir do vetor do Sol ao Nope:
          let target0 = sun.position.clone();
          let target4 = nopeMesh.position.clone();
          let V = target4.clone().sub(target0);
          let target1 = target0.clone().add(V.clone().multiplyScalar(0.25));
          let target2 = target0.clone().add(V.clone().multiplyScalar(0.50));
          let target3 = target0.clone().add(V.clone().multiplyScalar(0.75));
          let targets = [target0, target1, target2, target3, target4];
          
          // Zoom In
          if(currentZoomState === 0) {
            if(camera.position.distanceTo(target0) < thresholdsIn[0]) {
              currentZoomState = 1;
              let dir = new THREE.Vector3().subVectors(camera.position, target1);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target1).add(dir.multiplyScalar(thresholdsIn[0]));
              controls.target.copy(target1);
            }
          } else if(currentZoomState === 1) {
            let d = camera.position.distanceTo(target1);
            if(d < thresholdsIn[1]) {
              currentZoomState = 2;
              let dir = new THREE.Vector3().subVectors(camera.position, target2);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target2).add(dir.multiplyScalar(thresholdsIn[1]));
              controls.target.copy(target2);
            } else if(d > thresholdsOut[0]) {
              currentZoomState = 0;
              let dir = new THREE.Vector3().subVectors(camera.position, target0);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target0).add(dir.multiplyScalar(thresholdsOut[0]));
              controls.target.copy(target0);
            }
          } else if(currentZoomState === 2) {
            let d = camera.position.distanceTo(target2);
            if(d < thresholdsIn[2]) {
              currentZoomState = 3;
              let dir = new THREE.Vector3().subVectors(camera.position, target3);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target3).add(dir.multiplyScalar(thresholdsIn[2]));
              controls.target.copy(target3);
            } else if(d > thresholdsOut[1]) {
              currentZoomState = 1;
              let dir = new THREE.Vector3().subVectors(camera.position, target1);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target1).add(dir.multiplyScalar(thresholdsOut[1]));
              controls.target.copy(target1);
            }
          } else if(currentZoomState === 3) {
            let d = camera.position.distanceTo(target3);
            if(d < thresholdsIn[3]) {
              currentZoomState = 4;
              let dir = new THREE.Vector3().subVectors(camera.position, target4);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target4).add(dir.multiplyScalar(thresholdsIn[3]));
              controls.target.copy(target4);
            } else if(d > thresholdsOut[2]) {
              currentZoomState = 2;
              let dir = new THREE.Vector3().subVectors(camera.position, target2);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target2).add(dir.multiplyScalar(thresholdsOut[2]));
              controls.target.copy(target2);
            }
          } else if(currentZoomState === 4) {
            if(camera.position.distanceTo(target4) > thresholdsOut[3]) {
              currentZoomState = 3;
              let dir = new THREE.Vector3().subVectors(camera.position, target3);
              if(dir.length() === 0) { dir.set(1,0,0); }
              dir.normalize();
              camera.position.copy(target3).add(dir.multiplyScalar(thresholdsOut[3]));
              controls.target.copy(target3);
            }
          }
        }
        
        // ===============================
        // Demais funções (rotação dos planetas, etc.)
        function updatePlanetRotation(planet, time) {
          if(planet.rotationPeriod) {
            let rotationPeriodDays = planet.rotationPeriod/24;
            let angle = time * (2*Math.PI/rotationPeriodDays);
            if(planet.pivot && planet.tiltGroup) {
              planet.tiltGroup.rotation.y = angle;
            } else {
              planet.mesh.rotation.y = angle;
            }
          }
        }
        
        const minSpeedFactor = 365.256/3600;
        const maxSpeedFactor = 100 * 365.256/3600;
        let lastFrameTime = performance.now();
        
        function animate() {
          requestAnimationFrame(animate);
          let now = performance.now();
          let dt = (now - lastFrameTime)/1000;
          lastFrameTime = now;
          let speedFactor = minSpeedFactor + ((speedSetting - 1)/9) * (maxSpeedFactor - minSpeedFactor);
          simulationTime += dt * speedFactor;
          let simDate = new Date(refDate.getTime() + simulationTime*86400000);
          currentDateLabel.textContent = "Data Simulada: " + formatDate(simDate);
          
          // Atualiza posição orbital dos planetas
          planets.forEach(planet => {
            let pos = getPlanetPosition(planet, simulationTime);
            if(planet.pivot) {
              planet.pivot.position.copy(pos);
            } else {
              planet.mesh.position.copy(pos);
            }
          });
          
          // Atualiza rotação dos planetas
          planets.forEach(planet => {
            updatePlanetRotation(planet, simulationTime);
          });
          
          // Atualiza grupos de órbita das luas
          earthMoonOrbitGroup.position.copy(earthMesh.position);
          nopeMoonOrbitGroup.position.copy(nopeMesh.position);
          let earthMoonAngle = (simulationTime * 2*Math.PI/10) % (2*Math.PI);
          earthMoonOrbitGroup.rotation.y = earthMoonAngle;
          let nopeMoonAngle = (simulationTime * 2*Math.PI/10) % (2*Math.PI);
          nopeMoonOrbitGroup.rotation.y = nopeMoonAngle;
          let tiltIncrement = deg2rad(15);
          let nopeMoonTilt = (simulationTime/10) * tiltIncrement;
          nopeMoonOrbitGroup.rotation.x = nopeMoonTilt;
          
          // Atualiza nuvens de Nope
          nopeCloudsGroup.position.copy(nopeMesh.position);
          let nopePivotRotation = window.nopeTiltGroup ? window.nopeTiltGroup.rotation.y : 0;
          nopeCloudsGroup.rotation.y = nopePivotRotation/10;
          
          // Atualiza zoom automaticamente (sem animação)
          updateZoomTransitions();
          
          controls.update();
          renderer.render(scene, camera);
        }
        
        animate();
      })();
    </script>
  </body>
</html>
